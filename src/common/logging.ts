import fs from "node:fs";
import { EOL } from "node:os";
import path from "node:path";

import { isDebugMode } from "./utils";

/**
 * File logger, capable of writing log messages and truncating previous log files.
 */
export class Logger {
	/**
	 * Maximum size per log file (50MiB); when this limit is reached, the logs are truncated and re-indexed.
	 */
	private static readonly MAX_FILE_SIZE = 50 * 1024 * 1024;

	/**
	 * Minimum log level used to determine which log messages can be written; default is `INFO`, or `DEBUG` whilst a debugger can be attached.
	 */
	private logLevel = isDebugMode ? LogLevel.DEBUG : LogLevel.INFO;

	/**
	 * Path to the current log file.
	 */
	private readonly logPath;

	/**
	 * Current size of the active log file.
	 */
	private logSize = 0;

	/**
	 * Directory path where logs generated by this logger will be saved to.
	 */
	private readonly logsDir = path.join(process.cwd(), "logs");

	/**
	 * Name of the current plugin; used to generate log file names.
	 */
	private readonly pluginName = path.basename(process.cwd());

	/**
	 * Initializes a new instance of the {@link Logger} class.
	 */
	constructor() {
		this.logPath = this.getLogPath();
		this.truncateLogs();

		process.once("uncaughtException", (err) => this.logError("Process encountered uncaught exception", err));
	}

	/**
	 * Writes a debug log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public logDebug(message: string, error?: Error | unknown) {
		this.log(LogLevel.DEBUG, message, error);
	}

	/**
	 * Writes a warning log `error`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public logError(message: string, error?: Error | unknown) {
		this.log(LogLevel.ERROR, message, error);
	}

	/**
	 * Writes an info log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public logInfo(message: string, error?: Error | unknown) {
		this.log(LogLevel.INFO, message, error);
	}

	/**
	 * Write a trace log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public logTrace(message: string, error?: Error | unknown) {
		this.log(LogLevel.TRACE, message, error);
	}

	/**
	 * Writes a warning log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public logWarn(message: string, error?: Error | unknown) {
		this.log(LogLevel.WARN, message, error);
	}

	/**
	 * Sets the minimum log level used to determine which log message can be written; default is `INFO`, or `DEBUG` whilst a debugger can be attached.
	 *
	 * **Note:** `LogLevel` can only be set to `TRACE` or `DEBUG` whilst the plugin is in debug mode. Debug mode can be enabled by setting `Nodejs.Inspect` to `true` within the "manifest.json" file.
	 * @param value Minimum log level.
	 */
	public setLogLevel(value: LogLevel) {
		if ((value === LogLevel.DEBUG || value === LogLevel.TRACE) && !isDebugMode) {
			this.logWarn(`Log level cannot be set to ${LogLevel[value]} whilst not in debug mode.`);
			return;
		}

		this.logLevel = value;
	}

	/**
	 * Generates the file path for a log file associated with the specified `index`.
	 * @param index Index of the log file.
	 * @returns Full file path to the log file.
	 */
	private getLogPath(index = 0): string {
		return path.join(this.logsDir, `${this.pluginName}.00${index}.log`);
	}

	/**
	 * Writes a log `message` with the specified `logLevel`.
	 * @param logLevel Log level of the message, printed as part of the overall log message.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	private log(logLevel: LogLevel, message: string, error?: Error | unknown): void {
		if (logLevel > this.logLevel) {
			return;
		}

		const fd = fs.openSync(this.logPath, "a");
		const write = (message: string) => {
			fs.writeSync(fd, message);
			this.logSize += message.length;
		};

		try {
			write(`${new Date().toISOString()} ${LogLevel[logLevel].padEnd(5)} ${message}${EOL}`);
			if (error !== undefined) {
				if (error instanceof Error && error.stack) {
					write(`${error.stack}\n`);
				} else {
					write(`${error}`);
				}
			}
		} finally {
			fs.closeSync(fd);
		}

		if (this.logSize >= Logger.MAX_FILE_SIZE) {
			this.truncateLogs();
			this.logSize = 0;
		}
	}

	/**
	 * Truncates existing logs, ensuring there are only 10 log files at any given time, with the oldest being removed. The index of remaining files is increment to allow for a new log file to be created.
	 */
	private truncateLogs(): void {
		// When the logs directory is new, all we need to do is create it.
		if (!fs.existsSync(this.logsDir)) {
			fs.mkdirSync(this.logsDir);
			return;
		}

		// Get the current log files.
		const logFiles = fs
			.readdirSync(this.logsDir)
			.filter((file) => path.extname(file).toLowerCase() === ".log")
			.sort();

		for (let i = logFiles.length - 1; i >= 0; i--) {
			const logPath = path.join(this.logsDir, logFiles[i]);

			if (i > 9) {
				// Remove old log files.
				fs.rmSync(logPath);
			} else {
				// Increment remaining log files, ready for a new log file.
				fs.renameSync(logPath, this.getLogPath(i + 1));
			}
		}
	}
}

/**
 * Levels of logging.
 */
export enum LogLevel {
	/**
	 * Error message used to indicate an error was thrown, or something critically went wrong.
	 */
	ERROR = 0,

	/**
	 * Warning message used to indicate something went wrong, but the application is able to recover.
	 */
	WARN = 1,

	/**
	 * Information message for general usage.
	 */
	INFO = 2,

	/**
	 * Debug message used to detail information useful for profiling the applications runtime.
	 */
	DEBUG = 3,

	/**
	 * Trace message used to monitor low-level information such as method calls, performance tracking, etc.
	 */
	TRACE = 4
}
