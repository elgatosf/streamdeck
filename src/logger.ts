import fs, { WriteStream } from "node:fs";
import path from "node:path";

/**
 * File logger, capable of writing log messages and truncating previous log files.
 */
class Logger {
	/**
	 * Directory path where logs generated by this logger will be saved to.
	 */
	private readonly logsDir = path.join(process.cwd(), "logs");

	/**
	 * File stream responsible for writing to the active log file.
	 */
	private readonly logStream: WriteStream;

	/**
	 * Name of the current plugin; used to generate log file names.
	 */
	private readonly pluginName = path.basename(process.cwd());

	/**
	 * Minimum log level used to determine which log messages should be written.
	 */
	private logLevel = process.execArgv.includes("--inspect") ? LogLevel.DEBUG : LogLevel.INFO;

	/**
	 * Initializes a new logger.
	 */
	constructor() {
		this.prepareLogsDir();
		this.logStream = fs.createWriteStream(this.getLogFilePath(0), { flags: "a+" });
	}

	/**
	 * Writes a debug log `message`.
	 * @param message Message to write to the log.
	 */
	public debug(message: string) {
		this.log(LogLevel.DEBUG, message);
	}

	/**
	 * Writes a warning log `error`.
	 * @param message Message to write to the log.
	 */
	public error(message: string) {
		this.log(LogLevel.ERROR, message);
	}

	/**
	 * Writes an info log `message`.
	 * @param message Message to write to the log.
	 */
	public info(message: string) {
		this.log(LogLevel.INFO, message);
	}

	/**
	 * Writes a warning log `message`.
	 * @param message Message to write to the log.
	 */
	public warn(message: string) {
		this.log(LogLevel.WARN, message);
	}

	/**
	 * Writes a log `message` with the specified `logLevel`.
	 * @param logLevel Log level of the message, printed as part of the overall log message.
	 * @param message Message to write to the log.
	 */
	private log(logLevel: LogLevel, message: string): void {
		if (logLevel <= this.logLevel) {
			this.logStream.write(`${new Date().toISOString()} ${LogLevel[logLevel]} - ${message}\n`);
		}
	}

	/**
	 * Prepares the logs directory ready for a new log file to be created. The logs directory is created, excess log files are removed (older than 9), and all indexes of remaining log files are incremented.
	 */
	private prepareLogsDir(): void {
		// When the logs directory is new, all we need to do is create it.
		if (!fs.existsSync(this.logsDir)) {
			fs.mkdirSync(this.logsDir);
			return;
		}

		// Get the current log files.
		const logFiles = fs
			.readdirSync(this.logsDir)
			.filter((file) => path.extname(file).toLowerCase() === ".log")
			.sort();

		for (let i = logFiles.length - 1; i >= 0; i--) {
			const logPath = path.join(this.logsDir, logFiles[i]);

			if (i > 9) {
				// Remove old log files.
				fs.rmSync(logPath);
			} else {
				// Increment remaining log files, ready for a new log file.
				fs.renameSync(logPath, this.getLogFilePath(i + 1));
			}
		}
	}

	/**
	 * Generates the file path for a log file associated with the specified `index`.
	 * @param index Index of the log file.
	 * @returns Full file path to the log file.
	 */
	private getLogFilePath(index: number): string {
		return path.join(this.logsDir, `${this.pluginName}.00${index}.log`);
	}
}

/**
 * Levels of logging.
 */
enum LogLevel {
	/**
	 * Error message used to indicate an error was thrown, or something critically went wrong.
	 */
	ERROR = 0,

	/**
	 * Warning message used to indicate something went wrong, but the application is able to recover.
	 */
	WARN = 1,

	/**
	 * Information message for general usage.
	 */
	INFO = 2,

	/**
	 * Debug message used to detail low-level information useful for profiling the applications runtime.
	 */
	DEBUG = 3
}

/**
 * Logger capable of writing messages to a local log file, without relying on a connection with Stream Deck.
 * This instance is used when calling `streamDeck.logMessage(message)` to reduce communication between the plugin and the Stream Deck.
 * Log files can be found in the plugin's directory, under the "/logs" folder, and are truncated to the 10 most recent logs.
 */
export default new Logger();
