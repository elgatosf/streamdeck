import fs from "node:fs";
import path from "node:path";

/**
 * File logger, capable of writing log messages and truncating previous log files.
 */
export class Logger {
	/**
	 * Directory path where logs generated by this logger will be saved to.
	 */
	private readonly logsDir = path.join(process.cwd(), "logs");

	/**
	 * Path to the current log file.
	 */
	private readonly logPath;

	/**
	 * Name of the current plugin; used to generate log file names.
	 */
	private readonly pluginName = path.basename(process.cwd());

	/**
	 * Minimum log level used to determine which log messages can be written; default is `INFO`, or `DEBUG` whilst a debugger can be attached.
	 */
	private logLevel = this.canDebuggerBeAttached() ? LogLevel.DEBUG : LogLevel.INFO;

	/**
	 * Initializes a new logger.
	 */
	constructor() {
		this.logPath = this.getLogPath();
		this.truncateLogs();
	}

	/**
	 * Writes a debug log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public debug(message: string, error?: Error | unknown) {
		this.log(LogLevel.DEBUG, message, error);
	}

	/**
	 * Writes a warning log `error`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public error(message: string, error?: Error | unknown) {
		this.log(LogLevel.ERROR, message, error);
	}

	/**
	 * Writes an info log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public info(message: string, error?: Error | unknown) {
		this.log(LogLevel.INFO, message, error);
	}

	/**
	 * Write a trace log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public trace(message: string, error?: Error | unknown) {
		this.log(LogLevel.TRACE, message, error);
	}

	/**
	 * Writes a warning log `message`.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	public warn(message: string, error?: Error | unknown) {
		this.log(LogLevel.WARN, message, error);
	}

	/**
	 * Sets the minimum log level used to determine which log message can be written; default is `INFO`, or `DEBUG` whilst a debugger can be attached.
	 *
	 * **Note:** `LogLevel` can only be set to `TRACE` or `DEBUG` whilst the plugin is in debug mode. Debug mode can be enabled by setting `Nodejs.Inspect` to `true` within the "manifest.json" file.
	 * @param value Minimum log level.
	 */
	public setLogLevel(value: LogLevel) {
		if ((value === LogLevel.DEBUG || value === LogLevel.TRACE) && !this.canDebuggerBeAttached()) {
			this.warn(`Log level cannot be set to ${LogLevel[value]} whilst not in debug mode.`); // todo: Add a link to enabling `developer_mode`.
			return;
		}

		this.logLevel = value;
	}

	/**
	 * Gets a value indicating whether the current process is being executed with the `--inspect` flag, allowing for a debugger to be attached.
	 * @returns `true` when the application is running with the `--inspect` flag; otherwise `false`.
	 */
	private canDebuggerBeAttached(): boolean {
		return process.execArgv.includes("--inspect");
	}

	/**
	 * Writes a log `message` with the specified `logLevel`.
	 * @param logLevel Log level of the message, printed as part of the overall log message.
	 * @param message Message to write to the log.
	 * @param error Optional error to log with the `message`.
	 */
	private log(logLevel: LogLevel, message: string, error?: Error | unknown): void {
		if (logLevel <= this.logLevel) {
			const date = new Date()
				.toISOString()
				.replace(/T/, " ")
				.replace(/\.\d+Z/, "");

			const fd = fs.openSync(this.logPath, "a");

			try {
				fs.writeSync(fd, `${date} ${LogLevel[logLevel]} ${message}\n`);
				if (error !== undefined) {
					if (error instanceof Error && error.stack) {
						fs.writeSync(fd, `${error.stack}\n`);
					} else {
						fs.writeSync(fd, `${error}`);
					}
				}
			} finally {
				fs.closeSync(fd);
			}
		}
	}

	/**
	 * Truncates existing logs, ensuring there are only 10 log files at any given time, with the oldest being removed. The index of remaining files is increment to allow for a new log file to be created.
	 */
	private truncateLogs(): void {
		// When the logs directory is new, all we need to do is create it.
		if (!fs.existsSync(this.logsDir)) {
			fs.mkdirSync(this.logsDir);
			return;
		}

		// Get the current log files.
		const logFiles = fs
			.readdirSync(this.logsDir)
			.filter((file) => path.extname(file).toLowerCase() === ".log")
			.sort();

		for (let i = logFiles.length - 1; i >= 0; i--) {
			const logPath = path.join(this.logsDir, logFiles[i]);

			if (i > 9) {
				// Remove old log files.
				fs.rmSync(logPath);
			} else {
				// Increment remaining log files, ready for a new log file.
				fs.renameSync(logPath, this.getLogPath(i + 1));
			}
		}
	}

	/**
	 * Generates the file path for a log file associated with the specified `index`.
	 * @param index Index of the log file.
	 * @returns Full file path to the log file.
	 */
	private getLogPath(index = 0): string {
		return path.join(this.logsDir, `${this.pluginName}.00${index}.log`);
	}
}

/**
 * Levels of logging.
 */
export enum LogLevel {
	/**
	 * Error message used to indicate an error was thrown, or something critically went wrong.
	 */
	ERROR = 0,

	/**
	 * Warning message used to indicate something went wrong, but the application is able to recover.
	 */
	WARN = 1,

	/**
	 * Information message for general usage.
	 */
	INFO = 2,

	/**
	 * Debug message used to detail information useful for profiling the applications runtime.
	 */
	DEBUG = 3,

	/**
	 * Trace message used to monitor low-level information such as method calls, communication between the Stream Deck, etc..
	 */
	TRACE = 4
}

/**
 * Logger capable of writing messages to a local log file, without relying on a connection with Stream Deck.
 * This instance is used when calling `streamDeck.logMessage(message)` to reduce communication between the plugin and the Stream Deck.
 * Log files can be found in the plugin's directory, under the "/logs" folder, and are truncated to the 10 most recent logs.
 */
const logger = new Logger();

process.once("uncaughtException", (err) => logger.error("Process encountered uncaught exception", err));

export default logger;
